---
title: Feature Engineering
description: Define model inputs, outputs, and state relationships
---

Feature engineering in Onyx Engine centers on defining the relationships between your model's outputs and inputs. These relationships determine how the model simulates trajectories over multiple timesteps.

## Outputs and Inputs

Every Onyx model has two types of features:

- **Outputs**: What the model predicts (typically derivatives or deltas)
- **Inputs**: What the model receives (states and external inputs)

```python
from onyxengine.modeling import Output, Input

outputs = [
    Output(name='acceleration'),
]
inputs = [
    Input(name='velocity', parent='acceleration', relation='derivative'),
    Input(name='position', parent='velocity', relation='derivative'),
    Input(name='control_input'),
]
```

## Output Class

Outputs are features the neural network predicts. They form the core of your model's learning objective.

```python
Output(
    name='acceleration',           # Feature name (matches dataset column)
    dataset_feature=None,          # Optional: different column name in dataset
    scale='mean',                  # Scaling method
    parent=None,                   # For derived outputs
    relation=None                  # For derived outputs
)
```

### Multi-Output Models

You can predict multiple outputs:

```python
outputs = [
    Output(name='acceleration_x'),
    Output(name='acceleration_y'),
    Output(name='torque'),
]
```

### Derived Outputs

Outputs can derive from other outputs:

```python
outputs = [
    Output(name='jerk'),                                           # Direct prediction
    Output(name='acceleration', parent='jerk', relation='derivative'),  # Derived
]
```

## Input Class

Inputs are features fed to the model. They fall into two categories:

1. **States**: Inputs derived from outputs or other inputs (have `parent` and `relation`)
2. **External inputs**: Known values at each timestep (no `parent`)

```python
Input(
    name='velocity',               # Feature name
    dataset_feature=None,          # Optional: different column name in dataset
    scale='mean',                  # Scaling method
    parent='acceleration',         # Parent feature for states
    relation='derivative'          # Relationship type
)
```

## State Relations

The `relation` parameter defines how states update during simulation:

### Derivative

The parent is the time derivative of this feature:

```
feature[t+1] = feature[t] + parent[t] * dt
```

```python
# Velocity is the derivative of position
# So position integrates velocity over time
Input(name='position', parent='velocity', relation='derivative')

# Acceleration is the derivative of velocity
# So velocity integrates acceleration over time
Input(name='velocity', parent='acceleration', relation='derivative')
```

### Delta

The parent is the change per timestep:

```
feature[t+1] = feature[t] + parent[t]
```

```python
# The model predicts displacement directly
Input(name='position', parent='displacement', relation='delta')
```

### Equal

The feature equals the parent value:

```
feature[t+1] = parent[t]
```

```python
# State directly copies an output
Input(name='motor_state', parent='motor_output', relation='equal')
```

## State-Space Representation

Onyx models follow a state-space formulation similar to control theory:

$$\dot{x} = f(x, u)$$

Where:
- $\dot{x}$ are the model outputs (derivatives/deltas)
- $x$ are the states (inputs with relations)
- $u$ are the external inputs (inputs without relations)

### Example: Double Integrator

A system with acceleration as input, velocity and position as states:

```python
# Model predicts acceleration (the derivative of velocity)
outputs = [
    Output(name='acceleration'),
]

# States integrate outputs, control is external
inputs = [
    # velocity integrates acceleration
    Input(name='velocity', parent='acceleration', relation='derivative'),
    # position integrates velocity
    Input(name='position', parent='velocity', relation='derivative'),
    # control_input is known at each timestep
    Input(name='control_input'),
]
```

### Example: Multi-DOF System

A robot arm with joint positions, velocities, and torques:

```python
outputs = [
    Output(name='joint1_accel'),
    Output(name='joint2_accel'),
]

inputs = [
    # Joint 1 states
    Input(name='joint1_vel', parent='joint1_accel', relation='derivative'),
    Input(name='joint1_pos', parent='joint1_vel', relation='derivative'),
    # Joint 2 states
    Input(name='joint2_vel', parent='joint2_accel', relation='derivative'),
    Input(name='joint2_pos', parent='joint2_vel', relation='derivative'),
    # Control inputs
    Input(name='joint1_torque'),
    Input(name='joint2_torque'),
]
```

## Feature Scaling

The `scale` parameter controls how features are normalized:

| Value | Behavior | Use Case |
|-------|----------|----------|
| `'mean'` | Normalize to zero mean, unit std | Default, works for most features |
| `None` | No scaling | Already normalized data |
| `[min, max]` | Scale from [min, max] to [-1, 1] | Known physical bounds |

### Mean Scaling (Default)

Features are normalized using training set statistics:

```python
Output(name='acceleration', scale='mean')  # (x - mean) / std
```

### Range Scaling

For features with known physical limits:

```python
# Motor command between -10 and 10 Nm
Input(name='torque', scale=[-10, 10])

# Angle between -180 and 180 degrees
Input(name='angle', scale=[-180, 180])
```

### No Scaling

For pre-normalized features:

```python
Input(name='normalized_signal', scale=None)
```

## Dataset Feature Mapping

If your dataset column names differ from feature names:

```python
# Feature named 'velocity' maps to 'encoder_velocity' in dataset
Input(name='velocity', dataset_feature='encoder_velocity', ...)

# Feature named 'acceleration' maps to 'imu_accel_x' in dataset
Output(name='acceleration', dataset_feature='imu_accel_x')
```

## Common Patterns

### Predicting Derivatives

The most common pattern - predict the derivative, integrate to get the state:

```python
outputs = [Output(name='acceleration')]
inputs = [
    Input(name='velocity', parent='acceleration', relation='derivative'),
    Input(name='position', parent='velocity', relation='derivative'),
    Input(name='force'),
]
```

### Predicting Deltas

When predicting discrete changes rather than continuous derivatives:

```python
outputs = [Output(name='position_change')]
inputs = [
    Input(name='position', parent='position_change', relation='delta'),
    Input(name='command'),
]
```

### Direct State Prediction

When the model directly predicts the next state value:

```python
outputs = [Output(name='next_state')]
inputs = [
    Input(name='current_state', parent='next_state', relation='equal'),
    Input(name='action'),
]
```

### Chain of Derivatives

For higher-order systems:

```python
outputs = [Output(name='jerk')]  # Third derivative
inputs = [
    Input(name='acceleration', parent='jerk', relation='derivative'),
    Input(name='velocity', parent='acceleration', relation='derivative'),
    Input(name='position', parent='velocity', relation='derivative'),
    Input(name='control'),
]
```

## Validation Tips

<AccordionGroup>
  <Accordion title="Match dt to your data">
    The `dt` parameter must match your dataset's sampling period. Incorrect `dt` causes integration errors.
  </Accordion>

  <Accordion title="Check feature names">
    Ensure `name` (or `dataset_feature`) matches your dataset columns exactly, including case.
  </Accordion>

  <Accordion title="Verify parent chains">
    Each parent must be defined as either an output or another input. Undefined parents cause errors.
  </Accordion>

  <Accordion title="Consider physical units">
    When using derivative relations, ensure your units are consistent (e.g., velocity in m/s, position in m, dt in seconds).
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Training Configuration" icon="sliders-horizontal" href="/concepts/training-configuration">
    Configure optimizers and training parameters
  </Card>
  <Card title="Model Architectures" icon="box" href="/concepts/model-architectures">
    Choose the right neural network architecture
  </Card>
</CardGroup>
